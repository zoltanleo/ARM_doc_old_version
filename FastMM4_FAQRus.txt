Frequently Asked Questions
--------------------------

Q: Когда моя программа завершается, я получаю отчет FastMM об имеющихся утечках памяти. Что-то не так с FastMM?
A: К сожалению, нет. Если FastMM сообщает о блоках, которые утекли, то это значит, что они были рапределены, но никогда не были освобождены - это и есть утечки. Используйте утилиту наподобие Memproof, чтобы вычислить источник проблемы.

Q: Когда я разрешаю опцию FullDebugMode, мое приложение падает с access violation при запуске. Что не так?
A: Для FullDebugMode требуется библиотека FastMM_FullDebugMode.dll. Убедитесь, что она располагается в том же директории, что где находится приложение, или в доступном по path месте.

Q: Я разрешил FullDebugMode, но не получил информацию ни о модуле, ни о номере строки в снимках стека. Почему?
A: Для библиотеки FastMM_FullDebugMode.dll, чтобы определить модуль и строку в снимках стека, должно быть доступно что-нибудь из следующего: TD32 debug info, файл .map, файл .jdbg или внедренная отладочная информация JCL. Если ничего из этого недоступно, вы получите в снимках стека только адреса . Для того, чтобы показывались номера строк, нужно также разрешить "Debug Information", "Reference Info" и "Use Debug DCUs".

Q: Я разрешил FullDebugMode и получил лог - файл, содержащий снимок стека при утечках памяти, но без номера строк. Почему?
A: Чтобы получить номера строк, вам также нужно разрешить "Debug Information", "Reference Info" и "Use Debug DCUs" на закладке "Compiler" диалога "Project Options".

Q: Моя программа отлично работала совместно с менеджером памяти от Borland, но при работе с FastMM я получаю "Invalid Pointer Operation" или "Access Violation". Баг в FastMM?
A: Весьма маловероятно. Менеджер памяти настолько ответственный механизм любой программы, подвергающийся чрезвачайно тяжелой нагрузке, что ошибки подобного рода были бы отловлены при тестировании. FastMM работает иначе, чем менеджер памяти по умолчанию и более тщательно контролирует указатели, поэтому он отлавливает больше ошибок. Например: менеджер памяти по умолчанию может разрешить вам освободить тот же самый указатель дважды, тогда как FastMM немедленно бы выбросил исключение "Invalid Pointer Operation" при попытке это сделать. Скомпилируйте ваше приложение с опцией "CheckHeapForCorruption" в FastMM4.pas - это позволит вам отловить ошибки более ближе к источнику проблем.

Q: Моя программа при работе использует менеджер памяти X, но я получаю access violation при попытке использования FastMM. Почему?
A: Возможно, где-то в исходном коде осталась ссылка на старый менеджер памяти. Выполните "find in files" и убедитесь, что старый менеджер памяти неигде не встречается в разделах "uses" . FastMM контролирует, установлен ли он первым менеджером памяти, но многие другие менеджеры этого не делают, поэтому возможно, что другой MM может установить себя после FastMM.

Q: FastMM не сделал мою программу быстрее. Ага?!
A: Если ваша программа не выполняет многократное распределение памяти и освобождение памяти, то использование FastMM даст небольшое ускорение. Например: если ваше приложение тратит только 1% своего времени на распределение памяти с помощью менеджера памяти, используемого по умолчанию, то супербыстрый менеджер памяти в лучшем случае сможет дать только 1% прироста скорости. FastMM намного быстрее, чем установленный по умолчанию MM, однако если бутылочным горлыком в вашей программе является не управление памятью, то выигрыш будет не так велик, как бы вы хотели.

Q: Я добавил FastMM4.pas как самый первый модуль в мой файл проекта .dpr, однако когда я попробовал запустить мою программу, то получил сообщение, что это не самый первый модуль. Почему?
A: Если вы используете обработчик ошибок, который модифицирует порядок инициализации модулей(наподобие MadExcept или EurekaLog), вы должны изменить его конфигурацию так, чтобы FastMM инициализировался первым.

Q: Delphi 2005 падает с сообщением "Class 'TApplication', already if class map" (sic)когда я заменил дефолтный borlndmm.dll на FastMM DLL. Почему?
A: Из-за бага в Delphi 2005 (QC#14007). Есть неофициальный патч с фиксом этой ошибки. Смотрите подробности в FastMM4_Readme.txt.

Q: Я использую замену borlndmm.dll вместе с Delphi IDE. Когда я открываю две копии Delphi, а затем закрываю ону, то получаю отчет об утечке памяти. Почему?
A: При компиляции DLL вы должны установить опцию "NeverUninstall".

Q: Я использую замену borlndmm.dll совместно с Delphi 2005 IDE. Когда я закрываю IDE, он остается виден в списке задач (in task manager). Почему?
A: из-за бага (QC#14070). Когда компилируете DLL, вы должны установить опцию "NeverUninstall", чтобы все работало.

Q: Когда всплывают ошибки с памятью в "FullDebugMode", то отсутствует отладочная информация в снимке стека, только адреса. Почему?
A: Чтобы иметь аозможность узнать модуль/номер строки, приложение должно быть построено с использованием отладочной информации - она может быть в форме map - файла, файла .jdbg млм встроенной отладочной информации jcl. Кроме того, если адреса находятся внутри динамически загружаемой библиотеки DLL, которая была выгружена перед завершением, то FastMM не будет иметь возможность определить в ней модуль/номер строки.

Q: Моя программа работала отлично, но когда я разрешил "FullDebugMode" и запустил ее, я получил access violation по адресу $8080xxxx. Почему?
A: Вы попытались получить доступ к свойствам освобожденного объекта. Когда вы освобождаете блок в "FullDebugMode", FastMM заплняет свободную область памяти последовательностью байтов с кодом $80. Если затем пытаетесь использовать любые указатели, длинные строки или объекты внутри освобожденного объекта, то они все теперь будут указывать на адрес $80808080, который является зарезервированным.

Q: В режиме "FullDebugMode", когда появляются ошибки, снимок стека очень неполный. Почему?
A: Возможно, что вы запретили опцию "RawStackTraces". Без этой установки FastMM может только сформировать снимок стека для подпрограмм, которые устанавливают кадр стека. В окне "Project Options" на закладке "Compiler" , разрешите опцию "Stack Frames" для создания кадров стека ля всех процедур. Заметьте, что опция "RawStackTraces" обычно дает более полный снимок стека, но может давать ложные срабатывание (неустранимо) в снимке стека.

Q: Что я должен сделать, чтобы мои DLL и главное приложение совместно использовали FastMM так, чтобы я мог безопасно передавать между ними длинные строки и динамические массивы?
A: Наиболее простой путь - это определить ShareMM, ShareMMIfLibrary и AttemptToUseSharedMM в FastMM4.pas и добавить FastMM4.pas в верхушку списка секции uses файла .dpr для главного приложения и DLL.

Q: Я использую Windows x64 edition. Как разрешить моему приложению адресовать память больше, чем 2GB RAM?
A: Добавьте строку, содержащую {$SetPEFlags $20} к файлу .dpr . Это установит флаг LARGE_ADDRESS_AWARE при выполнении приложения, и заставит Windows x64 предоставить процессу все 4GB пользовательского пространства вместо обычных 2GB.

Q: Я получил следующую ошибку, когда я пытался использовать FastMM с приложением, скомпилированным для использования пакетов: "[Error] Need imported data reference ($G) to access 'IsMultiThread' from unit 'FastMM4'". Как сделать, чтобы это работало?
A: Разрешите опцию "UseRuntimePackages" в FastMM4Options.inc.

Q: Я использую рантайм - пакеты, а когда мое приложение завершается, а получаю отчет об оргромной утечке памяти следом, а затем - множеств access violations. Почему?
A: Скорее всего здесь проблема последовательности выгрузки пакетов: FastMM выгружается (и делает контроль за утечками) перед тем, как все живые указатели были освобождены, а когда приложение впоследствии пытается освободить оставшиеся живые указатели, происходят A/Vs. Убедитесь, что FastMM выгружается последним (использование sharemem совместно с заменой borlndmm.dll - это один из путей), или используйте опцию "NeverUninstall" и запретите отчет об утечке памяти.

Q: Начиная с версии 4.29 "FullDebugMode" очень медленный. Почему?
A: Из-за новой опции "RawStackTraces". Выключите ее и производительность будет как в предыдущей версии, но снимок стека будет меннее полным.

Q: Я земетил наличие прекомилированной отладочной (debug) borlndmm.dll для. Для чего она мне нужна?
A: Скорее всего, она Вам не нужна. Она нужна для охоты за багами IDE.

Q: Если я заменю borlndmm.dll, используемую в IDE, как это скажется на управлении памятью в моем приложении?
A: Никак. Если ваше приложение имеет sharemem.pas в качестве первого модуля в файле .dpr, то оно будет использовать первую borlndmm.dll, который оно найдет в path. Она не должно быть обязательно той же, что и используется в IDE.

Q: Замедляется ли мое приложение из-за контроля за утечками памяти?
A: Нет. Контроль за утечками выполняется только когда приложение закрывается.

Q: С установленными одновременно опциями FullDebugMode и RawStackTraces я иногда получаю снимок стека с элементами, которые не могут быть правильными. Почему?
A: К сожалению, это побочный эффект выполнения "сырой" (raw) обработки стека. В процессе сырой обработки стека выполняется более полная трассировка, чем альтернативная, покадровая трассировка (используется, когда запрещена опция RawStackTraces ), она иногда поднимает фальшивую тревогу, когда случается, что элементы данных стека ссылаются на действильные адреса возврата в коде программы. При сырой трассировке стека выполняются обширные проверки различий между данными и адресами возврата, которые иногда дают ложные срабатывания, что влечет за собой появление неверных элементов.

Q: Я пробовал использовать FastMM внутри библиотеки Kylix, но получил ошибку сегментации. Почему?
A: Linux требует, чтобы код внутри библиотек был размещен независимо (с базовым адресом, указываемым ebx). Ассемблерный код внутри FastMM использует регистр ebx для других надобностей и поэтому отсутствует позиционная независимость. Если вы желаете использоваь FastMM внутри библиотеки Kylix, то вы должны запретить опцию "ASMVersion" в FastMM4Options.inc.

Q: Как я могу совместно использовать менеджер памяти между приложениями BDS2006, которые не используют FastMM и библиотеками, которые используют FastMM (или наоборот)?
A: Добавьте файл SimpleShareMem.pas как первый модуль в секцию uses файла проекта, чтобы использовать default Delphi 2006 MM, и быть уверенным, что разрешен механизм совместного использования FastMM (опции "ShareMM" и "AttemptToUseSharedMM") для проектов, которые используют FastMM, а также разрешите опцию "EnableSharingWithDefaultMM".